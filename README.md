> Once you can name something, you've gained power over it.

## a a/a&aéa"a'a(a§aèa!açaàa)a-a★a^a¨a$a+a=a:a;a.a,a?a<a>a`a£a$a€aùa

## Table of Contents


## General notions:
### syntax vs semantics
### functions / procedures / methods
### polymorphism, interface / implementation
### abstraction
### low-level, high-level
### applications, libraries, application libraries, standard library
### static (resolved by code analysis) vs dynamic (resolved when program executes)
### validation, coercion
### code organization: modules & namespaces
### type systems
### mutation
### variables: names vs references
### types of programs: server, GUI, script, data processing, CLI, REPL lib
### API & clients
### producer and consumer
### state

## Architecture:
### the Optimization Metaphor: goals, constraints, and local optima
### design patterns
### separation of concerns / orthogonality / simplicity / complecting
### essential vs incidental complexity
### loose coupling
### code cohesion
### composability
### idempotency *
### environment coupling *
### componentization / IoC

## Under the Hood:
### computer internals: processors, CPU, RAM, disks, IO
### the Stack and the Heap
### memory management & garbage collection
### compilation & interpretation
### runtimes / VMs
### machine code, assembly

## Software services:
### storage
### I/O, network protocols
### operating systems
### queues, message brokers, log-based queues
### database systems
### data formats, serialization / encoding
### schedulers ★

## Quality attributes:
### functionality (it does what it's supposed to do)
### maintainability / evolvability (it's easy to change without breaking things or rewriting large parts of the code)
### extensibility
### clarity
### explicitness (few hidden asseumptions)
### declarative (specify what problem to solve, not how to solve it)
### accessibility (the code requires)

## Algorithms / Data structures / Collections:
### arrays, lists, sequential collections
### maps
### sets
### hashing
### trees
### DAGs / dependency systems / topological sorts ★
### regular expressions
### grammars ★

## Tools & practices:
### source control
### dependency managers & build tools
### refactoring
### testing
### debuggers
### benchmarking, profiling
### interactive development
### main IDE features: syntax highlighting, structural navigation, structural editing, refactoring commands, linting, autocompletion, ...
### peer programming ★
### code reviews ★
### methodologies: Agile, SCRUM, ...

## Concurrency:
### race conditions
### low-level primitives: threads, locks, atomic references
### atomicity
### synchronous vs asynchronous
### high-level primitives: queues, Actors, event loops, CSPs
### green threading ★

## Performance:
### latency
### throughput
### resource usage
### scalability
### contention
### Security:
### digest / checksum
### encryption
### authentication
### authorization

## Paradigms:
### structured programming
### procedural programming
### functional programming
### object-oriented / class-based / prototypal programming
### query languages / constraint solvers
### relational model
### logic programming ★
### production rule systems ★
### 'spreadsheet' (how to name this? 'reactive programming' maybe?) ★
### 'graph' (as embodied by the Plumatic/Graph library: how to name this?) ★
